// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.commands.*;
import frc.robot.commands.paths.DrivetrainConfig;
import frc.robot.commands.paths.PathableDrivetrain;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import java.util.List;
import java.util.ArrayList;
import com.kauailabs.navx.frc.*;
import frc.robot.Constants;
import frc.robot.Robot;
import frc.robot.Util;

import com.swervedrivespecialties.swervelib.Mk3SwerveModuleHelper;
import com.swervedrivespecialties.swervelib.SwerveModule;

import edu.wpi.first.wpilibj.SPI.Port;
import edu.wpi.first.wpilibj.geometry.Pose2d;
import edu.wpi.first.wpilibj.geometry.Rotation2d;
import edu.wpi.first.wpilibj.geometry.Translation2d;
import edu.wpi.first.wpilibj.kinematics.ChassisSpeeds;
import edu.wpi.first.wpilibj.kinematics.SwerveDriveKinematics;
import edu.wpi.first.wpilibj.kinematics.SwerveDriveOdometry;
import edu.wpi.first.wpilibj.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInLayouts;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonFX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;

/**
 *
 */
public class Drivetrain extends SubsystemBase implements PathableDrivetrain {

        private static final double MAX_VOLTAGE = 12.0;
        public static final double MAX_VELOCITY_METERS_PER_SECOND = 4.64;
        //ticks: 20352

        public static final double MAX_ANGULAR_VELOCITY_RADIANS_PER_SECOND = MAX_VELOCITY_METERS_PER_SECOND
                        / Math.hypot(Constants.DRIVETRAIN_TRACKWIDTH_METERS / 2.0,
                                        Constants.DRIVETRAIN_WHEELBASE_METERS / 2.0);

        private final SwerveModule frontLeftModule;
        private final SwerveModule frontRightModule;
        private final SwerveModule backLeftModule;
        private final SwerveModule backRightModule;
        private List<SwerveModule> swerveModules = new ArrayList<>();
        private DrivetrainConfig drivetrainConfig = new DrivetrainConfig();
        private final SwerveDriveKinematics kinematics = new SwerveDriveKinematics(
                        new Translation2d(Constants.DRIVETRAIN_TRACKWIDTH_METERS / 2.0,
                                        Constants.DRIVETRAIN_WHEELBASE_METERS / 2.0),
                        new Translation2d(Constants.DRIVETRAIN_TRACKWIDTH_METERS / 2.0,
                                        -Constants.DRIVETRAIN_WHEELBASE_METERS / 2.0),
                        new Translation2d(-Constants.DRIVETRAIN_TRACKWIDTH_METERS / 2.0,
                                        Constants.DRIVETRAIN_WHEELBASE_METERS / 2.0),
                        new Translation2d(-Constants.DRIVETRAIN_TRACKWIDTH_METERS / 2.0,
                                        -Constants.DRIVETRAIN_WHEELBASE_METERS / 2.0));

        private final SwerveDriveOdometry odometry;

        private Pose2d pose;
        private final AHRS navx = new AHRS(Port.kMXP);

        public Drivetrain() {
                ShuffleboardTab shuffleboardTab = Shuffleboard.getTab("Drivetrain");

                frontLeftModule = Mk3SwerveModuleHelper.createFalcon500(
                                shuffleboardTab.getLayout("Front Left Module", BuiltInLayouts.kList).withSize(2, 4)
                                                .withPosition(0, 0),
                                Mk3SwerveModuleHelper.GearRatio.FAST, Constants.FRONT_LEFT_MODULE_DRIVE_MOTOR,
                                Constants.FRONT_LEFT_MODULE_STEER_MOTOR, Constants.FRONT_LEFT_MODULE_STEER_ENCODER,
                                Constants.FRONT_LEFT_MODULE_STEER_OFFSET);

                frontRightModule = Mk3SwerveModuleHelper.createFalcon500(
                                shuffleboardTab.getLayout("Front Right Module", BuiltInLayouts.kList).withSize(2, 4)
                                                .withPosition(2, 0),
                                Mk3SwerveModuleHelper.GearRatio.FAST, Constants.FRONT_RIGHT_MODULE_DRIVE_MOTOR,
                                Constants.FRONT_RIGHT_MODULE_STEER_MOTOR, Constants.FRONT_RIGHT_MODULE_STEER_ENCODER,
                                Constants.FRONT_RIGHT_MODULE_STEER_OFFSET);

                backLeftModule = Mk3SwerveModuleHelper.createFalcon500(
                                shuffleboardTab.getLayout("Back Left Module", BuiltInLayouts.kList).withSize(2, 4)
                                                .withPosition(4, 0),
                                Mk3SwerveModuleHelper.GearRatio.FAST, Constants.BACK_LEFT_MODULE_DRIVE_MOTOR,
                                Constants.BACK_LEFT_MODULE_STEER_MOTOR, Constants.BACK_LEFT_MODULE_STEER_ENCODER,
                                Constants.BACK_LEFT_MODULE_STEER_OFFSET);

                backRightModule = Mk3SwerveModuleHelper.createFalcon500(
                                shuffleboardTab.getLayout("Back Right Module", BuiltInLayouts.kList).withSize(2, 4)
                                                .withPosition(6, 0),
                                Mk3SwerveModuleHelper.GearRatio.FAST, Constants.BACK_RIGHT_MODULE_DRIVE_MOTOR,
                                Constants.BACK_RIGHT_MODULE_STEER_MOTOR, Constants.BACK_RIGHT_MODULE_STEER_ENCODER,
                                Constants.BACK_RIGHT_MODULE_STEER_OFFSET);
                swerveModules.add(frontLeftModule);
                swerveModules.add(frontRightModule);
                swerveModules.add(backLeftModule);
                swerveModules.add(backRightModule);

                for (SwerveModule module : swerveModules) {
                        TalonFX driveMotor = module.getTalonDriveMotor();
                        
                        driveMotor.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor, 0, 0);
                        driveMotor.config_kF(0, 0.047);
                        driveMotor.config_kP(0, 0.02);

                }
                drivetrainConfig.maxAcceleration = 2.5; //1
                drivetrainConfig.maxVelocity=4; //4
                drivetrainConfig.maxAnglularVelocity=12;
                drivetrainConfig.maxAngularAcceleration =6;
                drivetrainConfig.rotationCorrectionP = 2;
                drivetrainConfig.maxCentripetalAcceleration = 11;

                pose = new Pose2d(0, 0, Rotation2d.fromDegrees(0));
                odometry = new SwerveDriveOdometry(kinematics, Rotation2d.fromDegrees(0), pose);

        }

        double lastSpeed = 0;
        long lastTime = 0;

        @Override
        public void periodic() {

                // Update the pose
                pose = odometry.update(Rotation2d.fromDegrees(getGyroAngle()), Util.stateFromModule(frontLeftModule),
                                Util.stateFromModule(frontRightModule), Util.stateFromModule(backLeftModule),
                                Util.stateFromModule(backRightModule));
                double speed = frontRightModule.getDriveVelocity();
                SmartDashboard.putNumber("speed", speed);

                double accel = Math.abs(lastSpeed - speed);

                double rawSpeed = frontRightModule.getTalonDriveMotor().getSelectedSensorVelocity();
                SmartDashboard.putNumber("rawSpeed", rawSpeed);

                SmartDashboard.putNumber("odo_x", pose.getX());
                SmartDashboard.putNumber("odo_y", pose.getY());
                if(Robot.getRightJoystick().getRawButton(8)){
                        resetPose(0,0,0);
                }
        }

        public void zeroGyroscope() {
                navx.zeroYaw();
        }

        /**
         * Goes positive as it goes counterclockwise. Degrees!
         * 
         * @return current angle in degrees
         */
        public double getGyroAngle() {
                return -navx.getAngle();
        }
        @Override
        public void drive(ChassisSpeeds chassisSpeeds) {
                SwerveModuleState[] states = kinematics.toSwerveModuleStates(chassisSpeeds);
                frontLeftModule.setWithVelocity(states[0].speedMetersPerSecond,
                                states[0].angle.getRadians());
                frontRightModule.setWithVelocity(states[1].speedMetersPerSecond,
                                states[1].angle.getRadians());
                backLeftModule.setWithVelocity(states[2].speedMetersPerSecond,
                                states[2].angle.getRadians());
                backRightModule.setWithVelocity(states[3].speedMetersPerSecond,
                                states[3].angle.getRadians());

        }
        
        public void driveVolts(ChassisSpeeds chassisSpeeds) {
                SwerveModuleState[] states = kinematics.toSwerveModuleStates(chassisSpeeds);
                frontLeftModule.set(states[0].speedMetersPerSecond / MAX_VELOCITY_METERS_PER_SECOND * MAX_VOLTAGE,
                                states[0].angle.getRadians());
                frontRightModule.set(states[1].speedMetersPerSecond / MAX_VELOCITY_METERS_PER_SECOND * MAX_VOLTAGE,
                                states[1].angle.getRadians());
                backLeftModule.set(states[2].speedMetersPerSecond / MAX_VELOCITY_METERS_PER_SECOND * MAX_VOLTAGE,
                                states[2].angle.getRadians());
                backRightModule.set(states[3].speedMetersPerSecond / MAX_VELOCITY_METERS_PER_SECOND * MAX_VOLTAGE,
                                states[3].angle.getRadians());
        }
        public void drive(double x, double y, double rot) {
                drive(new ChassisSpeeds(x, y, rot));
        }

        @Override
        public double getAngleRadians() {
                return Math.toRadians(getGyroAngle());
        }

        @Override
        public Pose2d getPose() {
                
                return pose;
        }
        public void resetPose(double x, double y, double rot){
                navx.reset();
                odometry.resetPosition(new Pose2d(x, y, new Rotation2d(rot)), new Rotation2d(rot));
        }
        @Override
        public ChassisSpeeds getSpeeds() {
                return kinematics.toChassisSpeeds(Util.stateFromModule(frontLeftModule),
                Util.stateFromModule(frontRightModule), Util.stateFromModule(backLeftModule),
                Util.stateFromModule(backRightModule));
        }

        @Override
        public DrivetrainConfig getConfig() {
                return drivetrainConfig;
        }

    


}
